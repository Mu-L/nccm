#!/usr/bin/python3
# vim:set shiftwidth=4 expandtab:

'''
NCurses ssh Connection Manager (nccm)
=====================================

![](images/program_screenshot.png)

Copyright (C) 2020 Kenneth Aaron.

flyingrhino AT orcon DOT net DOT nz

Freedom makes a better world: released under GNU GPLv3.

https://www.gnu.org/licenses/gpl-3.0.en.html

This software can be used by anyone at no cost, however,
if you like using my software and can support - please
donate money to a children's hospital of your choice.

This program is free software: you can redistribute it
and/or modify it under the terms of the GNU General Public
License as published by the Free Software Foundation:
GNU GPLv3. You must include this entire text with your
distribution.

This program is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE.
See the GNU General Public License for more details.


Manual install instructions
---------------------------

This is the easiest way to install nccm, you can of course
install and use nccm in any way you wish.

* Clone the project from the git repository:
  `git clone https://github.com/flyingrhinonz/nccm nccm.git`
* `cd nccm.git/nccm/`
* `sudo install -m 755 nccm -t /usr/local/bin/`


The ssh connections/config file `nccm.yml` should be
copied to any one of the following locations, and is
loaded from the first location found:
- `~/.config/nccm/nccm.yml`
- `~/.nccm.yml`
- `~/nccm.yml`
- `/etc/nccm.yml`


Tips on nccm.yml location - if you're a single user then
placement of nccm.yml doesn't matter and it's probably
easiest to place it in one of the home dir locations.
In a multiuser system, placing nccm.yml in each user's
home dir will allow each user to use their personalized
settings if nccm.yml is present, and if not present then
fallback to default settings from /etc/nccm.yml.


nccm requires Python3 to be installed on your machine,
which should already be present on most Linux boxes.
Most Python library dependencies are already present
as part of Python3 however the following may not be
present in which case you need to install them manually.


On Debian or similar use apt:
`sudo apt install python3-pip yamllint`

On Fedora or similar use dnf:
`sudo dnf install python3-pip yamllint`

Then install PyYAML:
`pip3 install --user PyYAML`


Before starting, edit the `nccm.yml` file and add your
own ssh connections. Formatting YAML is easy and the file
you downloaded from the project page is well documented
and has examples of every supported scenario.
Follow the structure in the file - provide the connection
name at the beginning of a line and sub config items
indented by two spaces. Don't forget the colons - these
are part of the YAML language.

Don't worry about ordering your SSH session blocks in any
specific way because nccm gives you "sort by" options
within the program.

Once you've finished editing, check your work with yamllint:
`yamllint nccm.yml`

If no errors are returned, then you've formatted your file
correctly, and it's safe to continue.

If nccm is accessible from your path and is executable,
typing nccm is all that's required to launch the TUI
(terminal user interface).
If you see Python 3 exceptions, check whether you have
satisfied the dependencies. Any exceptions should mention
any package that's missing.


nccm.yml settings
-----------------

This file is mostly used for ssh connection details, but
also supports program settings as follows.

These are global settings, affecting all sessions.

`nccm_config_controlmode`:
Controls the cursor movement mode. Two modes are supported:
- std:    Cursor keys move the marker as expected.
- focus:  Marker and list move independently.
          The list is designed to move while the marker
          remains fixed unless it is moved manually.

`nccm_config_loglevel`:
Controls log level of messages sent by nccm to syslog.
Use this for debugging. Default level is warning.
Supported levels: debug, info, warning, error, critical

`nccm_config_keepalive`:
Sends a message through the encrypted channel every
n seconds (0 to disable) to prevent idle sessions from
being disconnected.
You can customize this on a per-connection basis by using
the setting `keepalive: n` (optional).

`nccm_config_identity`
For public key authentication, normally ssh will load your
private key from the default locations. You can force ssh
to use your own file by putting it's path here. Or set to
`false` to let ssh do it's own thing.
You can customize this on a per-connection basis by using
the setting `identity: path` (optional).

`nccm_config_sshprogram`
By default nccm will use the ssh program as found in your
path. If you want to explicitly set the path to ssh, or
you want to use a different program - set it here.
This is a global setting that affects all your connections.


Controls
--------

In nccm_config_controlmode == std mode:

- Up/Down arrows:     Move the marker the traditional way
- Home/End:           Jump marker to list first/last entry
- PgUp/PgDn:          Page up/down in the list

In nccm_config_controlmode == focus mode:

- Up/Down arrows:     Scroll the list up/down
- Home/End:           Jump to list first/last entry
- PgUp/PgDn:          Page up/down in the list
- Shift Up/Down:      Move the marker up/down
- Shift Left/Right:   Move the marker to display top/bottom

In both modes:

- Left/Right arrows:  Scroll the list horizontally
- Tab:                Switch between text boxes
- Enter or Ctrl-m:    Connect to the selected entry
- Ctrl-h:             Display this help menu
- Ctrl-k              Toggle cursor mode std <--> focus
- Ctrl-q or Ctrl-c:   Quit the program
- F1-F5 or !@#$% :    Sort by respective column (1-5)


Usage
-----

`Conn` textbox:
Accepts integer values only (and !@#$% for sorting).
Pressing Enter here will connect to this connection ID,
as corresponding to a valid value in the full
unfiltered list (even if that particular connection
is hidden by unmatching text in the `Filter` textbox),
ignoring everything else (`Filter` textbox, highlighted
line) - even if they don't match.
If this textbox is empty, it will connect to the
connection marked by the highlighted line.

`Filter` textbox:
Type any filter text here.
Filtering occurs by searching text present in all visible
columns (does not search in any of the non-visble
settings you made in nccm.yml for example identity or
customargs).
Accepts any printable character and space.
Text is forced to lowercase, and the resulting filtering
is case insensitive.
Pressing Enter will connect to the connection highlighed
in red. This also works if you're in the `Conn` textbox
and it's empty.

Textboxes accept backspace to delete one char backwards,
inline editing not supported.

Displayed connection list is filtered by the combined
contents of all the fields as you type in real time.
Spaces delimit filters if typed into `Filter` textbox
and all filter entries are AND'ed.

nccm_config_controlmode == focus was inspired by vim
where you can move your display up/down around your work
while keeping your current line selected.


Command line arguments
----------------------

* Supply initial filtering text. Examples:
      `nccm abc xyz`
      `nccm -d ab cd ef`
    If there is only one match - nccm will connect to it
    immediately.

* -h  or --help :
    Display the help message.

* -d  or --debug :
    Force debug verbosity logging, ignoring any other
    logging settings everywhere else.

* -m  or --man :
    Display the man page.


Sorting
-------

F1-F5 keys sort by the respective fields 1-5.
The display shows 4 visible columms but we treat
username and server address as separate columns for
sorting purposes.
The Fn keys may be captured by certain GUIs so we have
an alternative - when focused on `Conn` window, press
Shift-1 through 5 (!@#$%) to toggle sorting by the
respective field number. If you type these special
characters in the `Filter` textbox they become standard
filters just like any printable character.
Pressing the same key again reverses the sort order.

```
Column #  Column name       Sort    Alternate sort
--------  -----------       ----    --------------
1         List serial #     F1      !
2         Friendly name     F2      @
3         User name         F3      #
4         Server address    F4      $
5         Comment           F5      %
```


Help text
---------

From within nccm: use `Ctrl-h` to display the help text.
From the command line: use `nccm -h` or `nccm --help`.
There isn't a man page yet so `man nccm` won't work.


Limitations
-----------

Will not store passwords. Please don't request this
feature because it won't be added.
Either use ssh passwordless login (by placing your
public key on the server in `.ssh/authorized_keys` - tip:
look up `ssh-copy-id`) or store your password in a
password manager and paste it when prompted.

Does not like window resizing and exits gracefully
displaying an error message.
It's safe to resize the window once connection
establishment is in progress or after connected to
your server.

Does not support highlighting filter keywords in search
results because this results in a messy and confusing
display once more than a couple keywords are used.

Text entry is limited to the length of the textboxes
which in turn are dictated by the width of your window.
This should be enough for most use cases though.


Troubleshooting
---------------

Starting nccm:
The most common problem is missing Python3 dependencies.
Run nccm and read the exception message - it will tell
you what's missing.
The second most common problem is different nccm and
nccm.yml versions. This usually happens if you download
a newer nccm version and use your existing and older
nccm.yml file although the reverse is true too. The error
will normally be in the `Load` method and the resulting
exception will resemble something like this (the line
number will most probably be different):
`File "/usr/local/bin/nccm", line 481, in Load`.
If this happens, best is to backup your nccm.yml then
download both nccm and nccm.yml, verify that nccm now
works properly, then update the newly downloaded nccm.yml
from your backup copy.
Another common problem is user errors in the nccm.yml file:
try `yamllint nccm.yml`. If yamllint passes and
nccm still fails: run as `nccm -d` and check syslog for
errors - you may see a message about the connection item
line that fails or at least the last line that succeeded.

Logging:
Look at your syslog file for nccm entries. Depending upon
the verbosity level set in the config file you may not see
much if at all anything.
By default the production level of the script logs WARNING
and above which results in syslog silence until something
bad happens.

Increase logging verbosity level to debug using the
`-d` or `--debug` command line arguments.

To permanently increase logging verbosity change this line
in the `nccm.yml` config file to debug:
`nccm_config_loglevel: debug`
This only comes into effect after the config file has
successfully loaded (does not change the log level for
code that runs before loading the config file).

And to log stuff that happens before the config file is
loaded and before the argument parser sets the debug level,
change this line inside the nccm code:
`LogWrite.setLevel(logging.DEBUG)`

Also - more debugging calls exist but are commented out in
the code due to too much logging. Enable them as required.

If you find bugs please update to the latest version of
nccm first (this may include updating your yaml file in
case the format changed). If the bug persists please report
it through the `issues` tab in github.


Hacking nccm
------------

Take something good and make it better!
The code is heavily commented, with the hope that it will
make life easier for modders and forkers.

The config file is simple yaml. If you already have a
collection of logins elsewhere in an accessible format -
writing a script to convert and append fields to nccm.yml
is easy.


Misc
----

This program aims to do one thing well - lets you make SSH
connections from an ncurses based manager with minimum
distraction. Feature requests that keep nccm on focus will
be considered.


Credits
-------

Big thanks goes to Andrew P. for suggesting features and
improvements.

'''

# Standard library imports:
import argparse
import collections
import curses
import datetime
import itertools
import logging
import logging.handlers
import operator
import os.path
import pathlib
import pydoc
import shlex
import string
import subprocess
import sys
import time

# Pay attention to these imports:
import yaml         # Requires: 'pip3 install --user PyYAML'


# This block handles logging to syslog:
LogWrite = logging.getLogger('nccm')
LogWrite.setLevel(logging.WARNING)
    # ^ Set this to logging.DEBUG or logging.WARNING for your INITIAL desired log level.
    #   Config file (nccm.yml) log level takes over from when it is loaded,
    #   this value controls logging verbosity until then.
    #   If you need to see verbose logging BEFORE the nccm.yml is loaded (which
    #   overrides this setting), make it DEBUG here. This will also let you
    #   troubleshoot problems that occur in the initial stages of nccm run - before
    #   the nccm.yml file is loaded.
LogWrite.propagate = False
    # ^ Prevents duplicate logging by ancestor loggers (if any)
LogHandler = logging.handlers.SysLogHandler(address = '/dev/log')
LogWrite.addHandler(LogHandler)
LogWriteFormatter = logging.Formatter('{}[%(process)d]: <%(levelname)s> '
    '(ProcessName: %(processName)s , Module: %(module)s , '
    'LoggerName: %(name)s , FuncName: %(funcName)s , '
    'LineNo: %(lineno)d , ThreadName: %(threadName)s):    '
    '%(message)s'.format('nccm'))
    # ^ Select the attributes to include in the log lines
    #   Documented here: https://docs.python.org/3/library/logging.html
    #     (LogRecord attributes)
LogHandler.setFormatter(LogWriteFormatter)
LogWrite.debug('nccm started with log level = {}'.format(LogWrite.getEffectiveLevel()))

# Global variables go here:

# Setup the supported directories/pathnames for the connections file.
# If you want to store nccm.yml in a directory that's not already supported
# or change the filename, do it here:
ConfigFile = 'nccm.yml'
ConfigFilePath = []
ConfigFilePath.append(str(pathlib.Path.home()) + '/.config/nccm/' + ConfigFile)
ConfigFilePath.append(str(pathlib.Path.home()) + '/.' + ConfigFile)
ConfigFilePath.append(str(pathlib.Path.home()) + '/' + ConfigFile)
ConfigFilePath.append('/etc/' + ConfigFile)

ScreenHeight = ScreenWidth = 0      # The terminal window dimensions
DisplayObjects = []     # A list of window objects that display info on
                        #   the screen (no user input)
TextboxObjects = []     # A list of editable textbox windows (user input)

HelpMenuItems = collections.OrderedDict((
    ( 'Arrows',     'Scroll' ),
    ( 'Enter',      'Select' ),
    ( 'ctrl-h',     'Help' ),
    ( 'ctrl-q',     'Quit' ),
))

ForceDebugLogging = False   # Force debug logging
FilterTextArg = ''          # Filter text supplied at the command line


class HelpTextDisplay:
    ''' This manages window objects for help lines '''

    def __init__(self, LinesCount=None, ColsCount=None,
        BeginY=None, BeginX=None):
        self.Window = curses.newwin(LinesCount, ColsCount, BeginY, BeginX)

        for Looper in HelpMenuItems:
            self.Window.addstr('  '+Looper, curses.color_pair(1))
            self.Window.addstr('-'+HelpMenuItems[Looper], curses.color_pair(2))

    def Display(self):
        self.Window.noutrefresh()


class BasicTextDisplay:
    ''' This manages window objects to display simple text '''

    def __init__(self, LinesCount=None, ColsCount=None,
        BeginY=None, BeginX=None, Text='', ColorPair=0, Name=False):

        self.Name = Name
        self.Window = curses.newwin(LinesCount, ColsCount, BeginY, BeginX)
        self.Window.addstr(Text, curses.color_pair(ColorPair))

    def Display(self):
        LogWrite.debug('class BasicTextDisplay: {} method Display completed'
            .format(self.Name))
        self.Window.noutrefresh()

class ServerXS:
    def __init__(self):
        self.ServerXSNum = 0
        self.FriendlyName = ""
        self.UserName = ""
        self.Address = ""
        self.UserAddr = ""
        self.Comment = ""
        self.KeepAlive = ""
        self.Identity = ""
        self.CustomArgs = []

class Connections:
    ''' This handles the connections list.

        TextFilters are the objects that hold user input (the textboxes) so that we can
            later filter the display with text from them (Display method).
        '''

    def __init__(self, LinesCount=None, ColsCount=None, BeginY=None,
        BeginX=None, ColorPair=0, TextFilters=None, stdscr=None, Name=False):

        # Window parameters:
        self.Name = Name
        self.SshProgram = 'ssh'     # Path to ssh command - updated from nccm.yml
        self.stdscr = stdscr
        self.ColorPair = ColorPair
        self.TextFilters = TextFilters
        self.MaxTextLines = LinesCount-1
        self.MaxTextWidth = ColsCount-2

        # Storage components:
        self.LoadedServersDict = {}
            # ^ The yaml connections file loaded into a dict. Apart from conversion to
            #   internal formats, this dict won't be used again.
        self.FullServersList = collections.defaultdict(ServerXS)
            # ^ Full list as imported from the loaded object
            #   This is the source list that we reuse during the program.
            #   It is also sorted in place if the user chooses sorting by column.
        self.MaxLenServerXSNum = 0  # Length of the longest serial number field
        self.MaxLenFriendlyName = 0 # Length of the longest friendly name
        self.MaxLenUserAddr = 0     # Length of the longest connection string command
                                    #   (root@server)
        self.MaxLenComment = 0      # Length of the longest comment column

        self.SortOrder = True       # Column sort order (flips between True/False)
        self.YOffset = 0            # Y offset for scrolling vertically
        self.XOffset = 0            # X offset for scrolling horizontally
        self.MaxLineLength = 0      # Result of formatting the text to fit the max
                                    #   column length
        self.MarkerLine = 0         # Highlighted line for connection selection
        self.SelectedEntry = None   # The connection number matching MarkerLine
        self.SelectedEntryVal = None    # Connection number value of the highlighted line
        self.DisplayResultsCount = 0    # Number of displayed results after filtering

        self.Window = curses.newwin(LinesCount, ColsCount, BeginY, BeginX)


    def Load(self):
        ''' Loads the connections file '''

        for FileLooper in ConfigFilePath:
            if os.path.exists(FileLooper):
                break
        LogWrite.debug('Found config file: FileLooper = {}'.format(FileLooper))

        with open (FileLooper, 'r') as ConfigFileToRead:
            self.LoadedServersDict = yaml.safe_load(ConfigFileToRead)
                # ^ yaml.load is not safe

        # This code is needed because FriendlyName connections without any
        # config items have a value of None. I need to replace it with {} for
        # the dict lookups to work later on:
        for Looper in self.LoadedServersDict:
            if self.LoadedServersDict[Looper] == None:
                self.LoadedServersDict[Looper] = {}
        LogWrite.debug('self.LoadedServersDict = {}'.format(self.LoadedServersDict))

        # Extract config items first to prevent them from being read as conns:
        self.ControlMode = self.LoadedServersDict.pop(
            'nccm_config_controlmode', 'std').lower()
                # ^ Controls how arrow keys move the display & the marker.
                #   Options are std, focus
        LogWrite.debug('Loaded config self.ControlMode = {}'.format(self.ControlMode))

        if ForceDebugLogging:
            LogWrite.debug('Command line arg --debug forced nccm to run in debug mode. '
            'Ignoring nccm_config_loglevel from nccm.yml ...')
            self.LoadedServersDict.pop('nccm_config_loglevel', 'WARNING')
                # ^ Just to remove this setting from the yml config

        else:
            LogWrite.setLevel(getattr(logging, self.LoadedServersDict.pop
                ('nccm_config_loglevel', 'WARNING').upper()))
            LogWrite.debug('Loaded config log level. Log level now = {}'
                .format(LogWrite.getEffectiveLevel()))
                # ^ Values documented here:
                #   https://docs.python.org/3/library/logging.html#levels

        # Handle loading of the default keepalive value from nccm_config_keepalive:
        self.DefaultKeepAlive = int(self.LoadedServersDict.pop(
            'nccm_config_keepalive', '0'))
                # ^ Controls the keep alive message frequency
        LogWrite.debug('Loaded config self.DefaultKeepAlive = {}'
            .format(self.DefaultKeepAlive))

        # Handle loading of the default identity value from nccm_config_identity:
        self.Identity = self.LoadedServersDict.pop(
            'nccm_config_identity', False)
            # This is the -i arg sent to ssh
        LogWrite.debug('Loaded config self.Identity = {}'
            .format(self.Identity))

        # Handle loading of the default ssh program from nccm_config_sshprogram:
        self.SshProgram = self.LoadedServersDict.pop(
            'nccm_config_sshprogram', 'ssh')
        LogWrite.debug('Loaded config self.SshProgram = {}'
            .format(self.SshProgram))

        LogWrite.debug('Completed loading config args, '
            'next we load the connections details ...')

        # Populate the FullServersList (list of config items as lists,
        # even unconfigured items):
        try:
            for ServerXSNum, FriendlyName in enumerate(sorted(
                self.LoadedServersDict.keys(), key=str.lower)):
                # whilst ServerXSNum is being used as the dict key here do not
                # assume that it'll be the ServerXSNum beyond this point. Always
                # use FSL.ServerXSNum if you want it.
                FSL = self.FullServersList[ServerXSNum] # too much typing. :)
                FSL.ServerXSNum = ServerXSNum
                FSL.FriendlyName = FriendlyName
                #LogWrite.debug('Processing FriendlyName = {} , ServerXSNum = {}'
                #    .format(FriendlyName, ServerXSNum))

                # The following supports extracting UserName & Address from FriendlyName
                # if UserName & Address are not supplied:
                FSL.UserName = self.LoadedServersDict[FriendlyName].get('user', False)
                if not FSL.UserName:
                    FSL.UserName = self.LoadedServersDict[FriendlyName].get(
                        'user', FriendlyName.split(sep='@')[0], 1)

                FSL.Address = self.LoadedServersDict[FriendlyName].get('address', False)
                if not FSL.Address:
                    FSL.Address = self.LoadedServersDict[FriendlyName].get(
                        'address', FriendlyName.split(sep='@')[1], 1)

                FSL.UserAddr = '{}@{}'.format(FSL.UserName, FSL.Address) # for convenience

                FSL.Comment = self.LoadedServersDict[FriendlyName].get('comment', '')
                    # ^ .get because item my be empty

                FSL.KeepAlive = self.LoadedServersDict[FriendlyName].get(
                    'keepalive', self.DefaultKeepAlive)
                        # ^ If custom keepalive supplied use that,
                        #   else use the default value

                # Build the KeepAlive ssh argument:
                FSL.KeepAlive = '-o ServerAliveInterval={}'.format(FSL.KeepAlive)
                    # ^ Note that KeepAlive will always be built - either from
                    #   the per-connection setting or from the default value.

                # Individually configured 'identity' values per connection
                # will be respected and Identity will become '-i <value>' .
                # Otherwise if the value of nccm_config_identity in nccm.yml
                # is configured then we assume it's a path to the new
                # default key and Identity will take it from there (prepending
                # the '-i ' part to it.
                # Otherwise it should be set to '' which will have no effect
                # upon the ssh command line:
                FSL.Identity = self.LoadedServersDict[FriendlyName].get('identity', False)
                    # ^ Note that per-connection "identity" may not be supplied
                    #   and also the default nccm_config_identity may be False.
                    #   The following code handles this situation

                # Build the Identity ssh argument per priority of supplied values:
                if FSL.Identity:            # Prefer the custom identity
                    FSL.Identity = '-i {}'.format(FSL.Identity)

                elif self.Identity:     # Or the configured default
                    FSL.Identity = '-i {}'.format(self.Identity)

                else:                   # Or keep it blank and ssh uses default key
                    FSL.Identity = ''

                FSL.CustomArgs = self.LoadedServersDict[FriendlyName].get('customargs', '')
                if isinstance(FSL.CustomArgs, str):
                    FSL.CustomArgs = shlex.split(FSL.CustomArgs)

                LogWrite.debug('ServerXSNum = {} , FriendlyName = {} , UserName = {}'
                    'Address = {} , UserAddr = {}, Comment = {} , KeepAlive = {} , '
                    'Identity = {} , CustomArgs = {}'
                        .format(FSL.ServerXSNum, FSL.FriendlyName,
                            FSL.UserName, FSL.Address, FSL.UserAddr,
                            FSL.Comment,
                            FSL.KeepAlive, FSL.Identity, ' '.join(FSL.CustomArgs)))

            LogWrite.debug('Completed loading all connections successfully')

        except Exception as Exc:
            LogWrite.error('Error loading connection. ServerXSNum = {} , FriendlyName = {}'
                .format(ServerXSNum, FriendlyName))
            raise Exc

        # Calculate the max length of each column:
        for Column in qw('ServerXSNum FriendlyName UserAddr Comment'):
            setattr(self, 'MaxLen{}'.format(Column), max(len(str(getattr(i, Column))) for i in self.FullServersList.values()))


    def Sort(self, Column):
        ''' Sorts the internal-use FullServersList list per the requested column '''

        LogWrite.debug('Sort by Column = {}'.format(Column))

        self.FullServersList = dict(enumerate(sorted(self.FullServersList.values(), key=operator.attrgetter(Column), reverse=self.SortOrder)))

        self.SortOrder = not(self.SortOrder)
            # ^ Reverse True to False, False to True so that next time this function
            #   is called the sort will be reversed.


    def Save(self):
        ''' Saves the connections file '''
        # Nothing here. Might add save feature if I allow user to add connection details


    def GetConnect(self, ServerXSNum):
        ''' Get link to connect to '''

        ServerXSNum = int(ServerXSNum)

        # Get the item line of the connection we want from the full connections list.
        # (This is the unmodified original list as it was loaded):
        for Server in self.FullServersList.values():
            if Server.ServerXSNum == ServerXSNum:
                SelectedEntry = Server
                break

        LogWrite.debug('SelectedEntry = {}'.format(SelectedEntry))

        # Remember that the connection line is a list of items.
        # Pull the correct items out of
        # the list to build the ssh connection line:
        SshCommand = (
            self.SshProgram + ' ' +
                # ^ "ssh" or your alternative command name
            SelectedEntry.UserAddr + ' ' +
                # ^ "user@host"
            SelectedEntry.KeepAlive + ' ' +
                # ^ -o ServerAliveInterval=KeepAlive
            SelectedEntry.Identity + ' ' +
                # ^ "-i path"   or ''
            ' '.join(SelectedEntry.CustomArgs)
                # ^ CustomArgs   or ''
            )

        LogWrite.debug('ServerXSNum (this is the connection list '
            'line number) = {} , SshCommand = "{}"'
                .format(ServerXSNum, SshCommand))
            # ^ This line logs as:
            #   SshCommand = "ssh stn@192.168.1.10 -o ServerAliveInterval=40 "
            #   Note the space at the end - this comes from the + ' ' after
            #   adding ServerAliveInterval=   because we're accommodating for the
            #   next field after it (all args being space delimited).
        return SshCommand


    def Display(self):

        # Check if the window was resized since it was started:
        NewScreenHeight, NewScreenWidth = self.stdscr.getmaxyx()
        LogWrite.debug('NewScreenHeight = {} , NewScreenWidth = {} '
            .format(NewScreenHeight, NewScreenWidth))

        if NewScreenHeight != ScreenHeight or NewScreenWidth != ScreenWidth:
            RestoreTerminal(self.stdscr)
            print('nccm: Resizing the window during menu display is not permitted.\n'
                'You may resize the window during or after connection initiation.\n')
            LogWrite.warning('Resizing the window during menu display is not permitted')
            sys.exit(1)

        FilterTextList = set()          # Unique text strings for filtering
        self.ResultsList = []           # Result of the filtering

        self.Window.erase()

        # Merge the users text input into a set whose uniqueness
        # improves search performance:
        for Looper in self.TextFilters:
            FilterTextList.update(set(Looper.Text.split(' ')))

        # Populate self.ResultsList with all line that match the above filter:
        for FSL in self.FullServersList.values():
            Line = ('{:<{ServerXSNumWidth}}    {:<{FriendlyNameWidth}}    '
                '{:<{UserAddrWidth}}    {:<{CommentWidth}}'
                 .format(
                    FSL.ServerXSNum,
                    FSL.FriendlyName,
                    FSL.UserAddr,
                    FSL.Comment,
                    ServerXSNumWidth = self.MaxLenServerXSNum,
                    FriendlyNameWidth = self.MaxLenFriendlyName,
                    UserAddrWidth = self.MaxLenUserAddr,
                    CommentWidth = self.MaxLenComment))

            if len(Line) > self.MaxLineLength:
                self.MaxLineLength = len(Line)

            if sorted(FilterTextList) == sorted(x for x in FilterTextList if x in Line):
                self.ResultsList.append(Line)

        self.ResultsList = [x.ljust(self.MaxLineLength, ' ') for x in self.ResultsList]
        self.DisplayResultsCount = 0

        if self.MarkerLine > (len(self.ResultsList)-1):
            self.MarkerLine = (len(self.ResultsList)-1)
        if self.MarkerLine < 0:
            self.MarkerLine = 0
        self.SelectedEntry = None

        for LineNumber, Looper in enumerate(
            self.ResultsList[self.YOffset:(self.YOffset+self.MaxTextLines)]):
            self.DisplayResultsCount += 1   # Number of lines displayed
            PaddedString = Looper[self.XOffset:(self.XOffset+self.MaxTextWidth)]

            if LineNumber == self.MarkerLine:
                self.Window.addstr(PaddedString, curses.color_pair(4))
                self.SelectedEntry = Looper
                self.SelectedEntryVal = int(self.SelectedEntry.lstrip().split()[0])
            else:
                self.Window.addstr(PaddedString)

            self.Window.addstr('\n')

        self.Window.noutrefresh()
        LogWrite.debug('class Connections: {} method Display completed. '
            'Number of results = {} , number of displayed results = {}'
            .format(self.Name, len(self.ResultsList), self.DisplayResultsCount))


class TextBox:
    ''' This manages objects that handle text input '''

    def __init__(self, LinesCount=None, ColsCount=None,
        BeginY=None, BeginX=None, ColorPair=0, FilterText='',
        Name=False):

        self.Name = Name
        self.Text = FilterText
            # ^ This is the text that the user enters.
            #   We pass in FilterText in case we need to load it from
            #   the command line --filter arg
        LogWrite.debug('TextBox {} : self.Text = {}'.format(self.Name, self.Text))
        self.MaxText = ColsCount-1
        self.Window = curses.newwin(LinesCount, ColsCount, BeginY, BeginX)
        self.Window.keypad(True)
            # ^ Get special keys support for this window.
            #   Calling 'stdscr.keypad(True)' is different and doesn't reflect
            #   in windows - it must be called separately.
            #   Very important - otherwise stuff like getch return stuff like arrow keys
            #   in multiple bytes (one per call) and it's screwed up.
        self.Window.bkgd(' ', curses.color_pair(ColorPair))
        self.Window.addstr(0, 0, self.Text)


    def Display(self):
        LogWrite.debug('class TextBox: {} method Display completed'
            .format(self.Name))
        self.Window.noutrefresh()


    def ZeroCursor(self):
        ''' Position the cursor at 0, x in this window.
            Call with:
                ConnBox.ZeroCursor()
            Takes into account the length of self.Text in case it was preloaded
            from the command line --filter arg.
        '''

        self.Window.move(0, len(self.Text))
            # ^ Position cursor at 0, x (axes are: y,x)


    def ActivateWindow(self):
        ''' Brings this window to the front.
            Call with:
                ConnBox.ActivateWindow()
        '''

        self.Window.noutrefresh()
        curses.doupdate()
        LogWrite.debug('Active window is now: {}'.format(self.Name))


    def ReadKey(self):
        UserKey = self.Window.getch()    # Read a key and return a code
        return UserKey


    def ProcessKey(self, Key):

        if Key == curses.KEY_BACKSPACE or Key == 263:   # Backspace key
            if len(self.Text) > 0:
                self.Text = self.Text[:-1]

        elif len(self.Text) < self.MaxText:
            self.Text += chr(Key).lower()
                # ^ Force to lower and search is case insensitive

        self.Window.clear()
        self.Window.addstr(0, 0, self.Text)

def qw(liststr: str):
    ''' analogous to Perl's qw() - split on whitespace and return list '''
    if liststr is None:
        return None
    else:
        return liststr.split()

def RestoreTerminal(stdscr):
    ''' Restore the terminal to a sane status '''

    curses.curs_set(1)          # Restore blinking cursor
    curses.echo()               # Restore terminal echo
    stdscr.keypad(False)        # Return special keys to normal
    curses.noraw()              # Return raw mode to normal
    curses.endwin()             # End curses session


def UpdateDisplay():
    ''' The window objects were added to DisplayObjects list,
        so here we need to use the Display method of those objects. '''

    global DisplayObjects

    for Looper in DisplayObjects:
        LogWrite.debug('Calling Looper = {} Display method ...'.format(Looper))
        Looper.Display()

    LogWrite.debug('Calling curses update screen (actually draw the changes we wrote '
        'to the window buffers) ...')
    curses.doupdate()
        # ^ Speed up display and avoid flickering by using 'window.noutrefresh'


def SetupCurses(stdscr):
    ''' Put all pre-run tests here. Any failure will exit the program. '''


    global ScreenHeight, ScreenWidth
    global FilterTextArg

    curses.curs_set(1)          # Enable the blinking cursor
    curses.noecho()             # Disable echo to the terminal
    stdscr.keypad(True)
        # ^ Get special keys support in stdscr. Per window setting also required
    curses.raw()                # Disable control codes

    curses.init_pair(1, curses.COLOR_YELLOW, curses.COLOR_BLACK)
    curses.init_pair(2, curses.COLOR_CYAN, curses.COLOR_BLACK)
    curses.init_pair(3, curses.COLOR_WHITE, curses.COLOR_BLUE)
    curses.init_pair(4, curses.COLOR_WHITE, curses.COLOR_RED)

    if not curses.has_colors(): # Color not supported
        RestoreTerminal(stdscr)
        print('nccm: This program requires color support\n')
        LogWrite.warning('This program requires color support')
        return False

    ScreenHeight, ScreenWidth = stdscr.getmaxyx()
    LogWrite.debug('ScreenHeight = {} , ScreenWidth = {}'
        .format(ScreenHeight, ScreenWidth))

    if ScreenWidth < 60 or ScreenHeight < 15:
        RestoreTerminal(stdscr)
        print('nccm: Window must be at least 60x15\n')
        LogWrite.warning('Window must be at least 60x15. '
            'ScreenHeight = {} , ScreenWidth = {}'
                .format(ScreenHeight, ScreenWidth))
        return False

    if len(FilterTextArg) > ScreenWidth-32:
        RestoreTerminal(stdscr)
        print('nccm: Filter text too long ({} chars). '
            'For your window size enter no more than {} chars\n'
                .format(len(FilterTextArg), ScreenWidth-32))
        LogWrite.warning('nccm: Filter text too long ({} chars). '
            'For your window size enter no more than {} chars\n'
                .format(len(FilterTextArg), ScreenWidth-32))
        return False


def SetupWindows(stdscr):
    ''' Create the various windows '''

    global ScreenHeight, ScreenWidth
    global DisplayObjects
    global TextboxObjects

    LogWrite.debug('Function SetupWindows started - create the various windows')

    # Help text display window:
    HelpBox = HelpTextDisplay(LinesCount=1, ColsCount=ScreenWidth,
        BeginY=ScreenHeight-1, BeginX=0)
    DisplayObjects.append(HelpBox)      # Add this window to the displayable windows
    LogWrite.debug('HelpBox window built')

    # Connection text display window:
    ConnText = BasicTextDisplay(LinesCount=1, ColsCount=10,
        BeginY=ScreenHeight-3, BeginX=2, Text='Conn #', ColorPair=1,
        Name='ConnText')
    DisplayObjects.append(ConnText)
    LogWrite.debug('ConnText window built')

    # Connection text input window:
    ConnBox = TextBox(LinesCount=1, ColsCount=8,
        BeginY=ScreenHeight-3, BeginX=10, ColorPair=3,
        FilterText='', Name='ConnBox')
    DisplayObjects.append(ConnBox)
        # ^ Add this window to the displayable windows
    TextboxObjects.append(ConnBox)
        # ^ Add this window to the windows that store user input.
        #   We do this because later we filter the ConnectionsList
        #   display output based upon the text here.
    LogWrite.debug('ConnBox window built')

    # Filter text display window:
    FilterText = BasicTextDisplay(LinesCount=1, ColsCount=10,
        BeginY=ScreenHeight-3, BeginX=20, Text='Filter:', ColorPair=1,
        Name='FilterText')
    DisplayObjects.append(FilterText)
    LogWrite.debug('FilterText window built')

    # Filter text input window:
    FilterBox = TextBox(LinesCount=1, ColsCount=ScreenWidth-31,
        BeginY=ScreenHeight-3, BeginX=29, ColorPair=3,
        FilterText=FilterTextArg, Name='FilterBox')
            # ^ Preload it with whatever was supplied as --filter command line arg

    DisplayObjects.append(FilterBox)
    TextboxObjects.append(FilterBox)
    LogWrite.debug('FilterBox window built')

    # Connections list text display window:
    ConnectionsList = Connections(LinesCount=ScreenHeight-3,
        ColsCount=ScreenWidth, BeginY=0, BeginX=0, ColorPair=0,
        TextFilters=[FilterBox, ConnBox] , stdscr=stdscr,
        Name='ConnectionsList')
    ConnectionsList.Load()
        # ^ Load the connections list config file into this object (normal operation)
    DisplayObjects.append(ConnectionsList)
    LogWrite.debug('ConnectionsList window built')

    CyclicTextboxObjects = itertools.cycle(TextboxObjects)
        # ^ Call this after adding all the textbox windows
        #   We will use it as a cyclic list iterator so that every press of TAB
        #   will give us the next textbox object in the list.

    return ConnectionsList, ConnBox, FilterBox, CyclicTextboxObjects


def DisplayHelp():
    ''' Display the help text '''

    pydoc.pipepager(__doc__, cmd='less -i --dumb --no-init')
        # ^ Print the text in through the less pager
        #   so we can get paging, search, etc


def MainCursesFunction(stdscr):

    ConnectString = False

    if SetupCurses(stdscr) == False:       # Something failed in setup or tests
        LogWrite.error('SetupCurses(stdscr) failed')
        return

    LogWrite.debug('Setting up the ConnectionsList, ConnBox, FilterBox, '
        'CyclicTextboxObjects windows ...')
    ConnectionsList, ConnBox, FilterBox, CyclicTextboxObjects = SetupWindows(stdscr)
    UpdateDisplay()
    ActiveWindow = FilterBox    # The first window to read user input from
    ActiveWindow.ZeroCursor()
        # ^ We have no input text so activate ConnBox window and zero the cursor.
        #   Failure to do this will position the cursor at the last window drawn.

    # This block loops in the CyclicTextboxObjects until it's positioned at ActiveWindow.
    # We need this because the initial starting point may not be correct and the first
    # time we press TAB may do nothing:
    for Looper in CyclicTextboxObjects:
        if Looper == ActiveWindow:
            break

    if FilterTextArg and ConnectionsList.DisplayResultsCount == 1:
        # ^ User entered command line filter and there was only one match -
        #   connect to it immediately.
        LogWrite.debug('FilterTextArg supplied and '
            'ConnectionsList.DisplayResultsCount == 1 . '
            'Automatically connect to this server ...')
        ConnectString = ConnectionsList.GetConnect(
            ConnectionsList.SelectedEntryVal)
        RestoreTerminal(stdscr)
        return ConnectString

    while True:
        UserKey = ActiveWindow.ReadKey()
        LogWrite.debug('Keyboard entry UserKey = {}'.format(UserKey))

# This block is not required any more since I handle it better in
#   Connections.Display() method:
#        if UserKey == -1:       # Happens when window is resized
#            # ^ If I don't capture this, window resize causes a curses exception
#            LogWrite.debug('Detected window resize')
#            pass

        if UserKey == 9:    # Tab key (move between text boxes)
            LogWrite.debug('Handle Tab key ...')
            ActiveWindow = next(CyclicTextboxObjects)
                # ^ See the 'for Looper in CyclicTextboxObjects:' comment above
            ActiveWindow.ActivateWindow()
                # ^ Get the next item in the iterable and run it's ActivateWindow method.
                #   This is effectively the next textbox window object

        # Handle text entry in FilterBox:
        elif ( (chr(UserKey) in string.digits
            or chr(UserKey) in string.ascii_letters
            or chr(UserKey) in string.punctuation
            or UserKey == 32        # Space
            or UserKey == curses.KEY_BACKSPACE
            or UserKey == 263)      # Backspace key
            and ActiveWindow == FilterBox ):
            # ^ Filterbox accepts any printable character or backspace
            #   Using string.punctuation crashes on ctrl-j input so I explictly
            #   identify the characters accepted.
                LogWrite.debug('Handle text entry in FilterBox ...')
                ConnectionsList.YOffset = 0
                ConnectionsList.XOffset = 0
                    # ^ Keypress received so reset the display to the beginning of the list
                ActiveWindow.ProcessKey(UserKey)

        # Handle text entry in ConnBox:
        elif ( (chr(UserKey) in string.digits
            or UserKey == curses.KEY_BACKSPACE
            or UserKey == 263)              # Backspace key
            and ActiveWindow == ConnBox ):
            # ^ Filterbox accepts any digit or backspace
                LogWrite.debug('Handle text entry in ConnBox ...')
                ActiveWindow.ProcessKey(UserKey)

        elif ( UserKey == 33                # ! key (sort by column #1)
            and ActiveWindow == ConnBox ):
                ConnectionsList.Sort('ServerXSNum')

        elif ( UserKey == 64                # @ key (sort by column #2)
            and ActiveWindow == ConnBox ):
                ConnectionsList.Sort('FriendlyName')

        elif ( UserKey == 35                # # key (sort by column #3)
            and ActiveWindow == ConnBox ):
                ConnectionsList.Sort('UserName')

        elif ( UserKey == 36                # $ key (sort by column #4)
            and ActiveWindow == ConnBox ):
                ConnectionsList.Sort('Address')

        elif ( UserKey == 37                # % key (sort by column #5)
            and ActiveWindow == ConnBox ):
                ConnectionsList.Sort('Comment')

        elif UserKey == 337:                # Shift up arrow
            if ConnectionsList.ControlMode == 'focus':
                if ConnectionsList.MarkerLine > 0:
                    ConnectionsList.MarkerLine -= 1

        elif UserKey == 336:                # Shift down arrow
            if ConnectionsList.ControlMode == 'focus':
                if ConnectionsList.MarkerLine < (ConnectionsList.DisplayResultsCount-1):
                    ConnectionsList.MarkerLine += 1

        elif UserKey == 393:                # Shift left arrow
            if ConnectionsList.ControlMode == 'focus':
                ConnectionsList.MarkerLine = 0

        elif UserKey == 402:                # Shift right arrow
            if ConnectionsList.ControlMode == 'focus':
                ConnectionsList.MarkerLine = (ConnectionsList.DisplayResultsCount-1)

        elif UserKey == curses.KEY_UP:      # Up arrow
            if ConnectionsList.ControlMode == 'focus':
                if ConnectionsList.YOffset > 0:
                    ConnectionsList.YOffset -= 1
            elif ConnectionsList.ControlMode == 'std':
                if ConnectionsList.MarkerLine > 0:
                    ConnectionsList.MarkerLine -= 1
                elif len(ConnectionsList.ResultsList) - ConnectionsList.YOffset > 0:
                    if ConnectionsList.YOffset >1:
                        ConnectionsList.YOffset -= 1
                    else:
                        ConnectionsList.YOffset = 0

        elif UserKey == curses.KEY_DOWN:    # Down arrow
            if ConnectionsList.ControlMode == 'focus':
                if (len(ConnectionsList.ResultsList) -
                    ConnectionsList.YOffset > ConnectionsList.MaxTextLines):
                    ConnectionsList.YOffset += 1
            elif ConnectionsList.ControlMode == 'std':
                if ConnectionsList.MarkerLine < (ConnectionsList.DisplayResultsCount-1):
                    ConnectionsList.MarkerLine += 1
                elif (len(ConnectionsList.ResultsList) -
                    ConnectionsList.YOffset > ConnectionsList.MaxTextLines):
                    ConnectionsList.YOffset += 1

        elif UserKey == curses.KEY_HOME:    # Home key
            if ConnectionsList.ControlMode == 'focus':
                ConnectionsList.YOffset = 0
            elif ConnectionsList.ControlMode == 'std':
                ConnectionsList.YOffset = 0
                ConnectionsList.MarkerLine = 0

        elif UserKey == curses.KEY_END:     # End key
            if ConnectionsList.ControlMode == 'focus':
                if len(ConnectionsList.ResultsList) > ConnectionsList.MaxTextLines:
                    ConnectionsList.YOffset = (len(ConnectionsList.ResultsList) -
                        ConnectionsList.MaxTextLines)
            elif ConnectionsList.ControlMode == 'std':
                if len(ConnectionsList.ResultsList) > ConnectionsList.MaxTextLines:
                    ConnectionsList.YOffset = (len(ConnectionsList.ResultsList) -
                        ConnectionsList.MaxTextLines)
                ConnectionsList.MarkerLine = (ConnectionsList.DisplayResultsCount-1)

        elif UserKey == curses.KEY_PPAGE:   # PageUp key
            ConnectionsList.YOffset -= ConnectionsList.MaxTextLines
            if ConnectionsList.YOffset < 0:
                ConnectionsList.YOffset = 0

        elif UserKey == curses.KEY_NPAGE:   # PageDown key
            ConnectionsList.YOffset += ConnectionsList.MaxTextLines
            if (ConnectionsList.YOffset > (len(ConnectionsList.ResultsList) -
                ConnectionsList.MaxTextLines)):
                ConnectionsList.YOffset = (len(ConnectionsList.ResultsList) -
                    ConnectionsList.MaxTextLines)

        elif UserKey == curses.KEY_LEFT:    # Left arrow (scroll left)
            ConnectionsList.XOffset -= (ConnectionsList.MaxTextWidth //3)
            if ConnectionsList.XOffset < 0:
                ConnectionsList.XOffset = 0

        elif UserKey == curses.KEY_RIGHT:   # Right arrow (scroll right)
            ConnectionsList.XOffset += (ConnectionsList.MaxTextWidth //3)
            if (ConnectionsList.XOffset > (ConnectionsList.MaxLineLength -
                ConnectionsList.MaxTextWidth)):
                ConnectionsList.XOffset = (ConnectionsList.MaxLineLength -
                    ConnectionsList.MaxTextWidth)

        elif UserKey == 265:                # F1 key (sort by column #1)
            ConnectionsList.Sort('ServerXSNum')

        elif UserKey == 266:                # F2 key (sort by column #2)
            ConnectionsList.Sort('FriendlyName')

        elif UserKey == 267:                # F3 key (sort by column #3)
            ConnectionsList.Sort('UserName')

        elif UserKey == 268:                # F4 key (sort by column #4)
            ConnectionsList.Sort('Address')

        elif UserKey == 269:                # F4 key (sort by column #5)
            ConnectionsList.Sort('Comment')

        elif ((UserKey == curses.KEY_ENTER or UserKey in [10, 13])  # Enter key
            and ActiveWindow == ConnBox
            and ConnBox.Text):
                LogWrite.debug('Handle Enter key in ConnBox ...')
                if (int(ConnBox.Text) >= 0
                    and int(ConnBox.Text) <= (len(ConnectionsList.FullServersList) -1)):
                        ConnectString = ConnectionsList.GetConnect(ConnBox.Text)
                        break

        elif ((UserKey == curses.KEY_ENTER or UserKey in [10, 13])
            and ConnectionsList.SelectedEntry):  # Enter key
                LogWrite.debug('Handle Enter key in FilterBox ...')
                    # ^ Well, it has to be FilterBox because we explicitly checked
                    #   for ConnBox earlier...
                ConnectString = ConnectionsList.GetConnect(
                    ConnectionsList.SelectedEntryVal)
                break

        elif UserKey == 8:      # Ctrl-h key (help)
            curses.endwin()     # De-initialize and return terminal to normal status
            DisplayHelp()

        elif UserKey == 11:     # Ctrl-k key (toggle cursor mode)
            if ConnectionsList.ControlMode == 'std':
                ConnectionsList.ControlMode = 'focus'
            else:
                ConnectionsList.ControlMode = 'std'

        elif UserKey == 17 or UserKey == 3:     # ctrl-q / ctrl-c (quit)
            break

        UpdateDisplay()
        ActiveWindow.ActivateWindow()

    RestoreTerminal(stdscr)
    return ConnectString


def ParseArgs():
    ''' Handle any command line arguments supplied '''

    global ForceDebugLogging
    global FilterTextArg

    parser = argparse.ArgumentParser(
        description = 'NCurses Connection Manager',
        epilog = 'Thank you for using nccm',
        #add_help = False )
            # ^ Bypass the built in argparse help generator and release
            #   the -h and --help args for our own use.
        )

    parser.add_argument('-d', '--debug',
        help='force debug verbosity logging, ignore other logging settings',
        action='store_true' )

    parser.add_argument('-m', '--man',
        help='display nccm man page and exit',
        action='store_true' )

    parser.add_argument('filter_text',
        nargs='*',
        help="supply initial filter text, example: nccm -d xyz abc . "
            "If there is only one match - connect to it immediately" )

    args = parser.parse_args()
    LogWrite.debug('args object = {}'.format(args))

    if args.debug:
        LogWrite.setLevel(logging.DEBUG)
        ForceDebugLogging = True
        LogWrite.debug('Received command line arg --debug forcing nccm '
            'to run in debug mode')

    LogWrite.debug('parser object = {}'.format(parser))
    LogWrite.debug('args object = {}'.format(args))

    if args.filter_text:
        FilterTextArg = args.filter_text
        LogWrite.debug('FilterTextArg = {}'.format(FilterTextArg))
        FilterTextArg = ' '.join(FilterTextArg)
            # ^ Stored in class TextBox.Text as a space delimited string
        LogWrite.debug('As a string: FilterTextArg = {}'.format(FilterTextArg))

    if args.man:
        DisplayHelp()
        sys.exit(0)


def main(*args):

    ParseArgs()     # Command line args processing happens here
    ConnectString = curses.wrapper(MainCursesFunction)

    if ConnectString:
        print('nccm: About to ssh using:\n{}\n'.format(ConnectString))
        ExtCommand = shlex.split(ConnectString)
            # ^ Split the command line into arguments
        LogWrite.debug('About to subprocess.run ExtCommand = {} ...'
            .format(ExtCommand))
        StartTime = time.time()
        subprocess.run(ExtCommand)              # Connect to the ssh server
        EndTime = time.time()
        SessionTime = round(EndTime - StartTime)
        print('nccm: Completed ssh using:\n{}\nSession time was: '
            '{} ({} seconds)\n'
                .format(ConnectString, datetime.timedelta(seconds=SessionTime),
                    SessionTime))
        LogWrite.debug('Completed ssh using: {} . SessionTime was: {} seconds'
            .format(ConnectString, SessionTime))


if __name__ == '__main__':
        main()

